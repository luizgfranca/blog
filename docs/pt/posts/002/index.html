<!DOCTYPE html>
<html lang="pt" dir="auto">

<head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Como calcular uma primeira medi√ß√£o instant√¢nea de m√©tricas sobre indicadores cumulativos em tempo real | Luiz G. Fran√ßa</title>
<meta name="keywords" content="">
<meta name="description" content="Suponha que precisamos calcular dados a partir de um indicador cumulativo para gerar gr√°ficos ou m√©tricas em tempo real para interpreta√ß√£o por parte dos usu√°rios de uma aplica√ß√£o. No entanto, esse indicador √© gerenciado por um processo externo, e n√£o temos como saber exatamente quando ele √© atualizado. Quais estrat√©gias podemos adotar para processar essas informa√ß√µes?
Esse √© um problema que encontrei em um projeto e que, a primeira vista, parece simples.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/pt/posts/002/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/blog/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/posts/002/">
<link rel="alternate" hreflang="pt" href="http://localhost:1313/blog/pt/posts/002/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
    
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

    
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/blog/pt/" accesskey="h" title="Luiz G. Fran√ßa (Alt + H)">Luiz G. Fran√ßa</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/blog/" title="üá∫üá∏"
                            aria-label=":us:">üá∫üá∏</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/blog/pt/">In√≠cio</a>&nbsp;¬ª&nbsp;<a href="http://localhost:1313/blog/pt/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Como calcular uma primeira medi√ß√£o instant√¢nea de m√©tricas sobre indicadores cumulativos em tempo real
    </h1>
    <div class="post-meta"><span title='2025-02-28 17:18:38 -0300 -03'>fevereiro 28, 2025</span>&nbsp;|&nbsp;Tradu√ß√µes:
<ul class="i18n_list">
    <li>
        <a href="http://localhost:1313/blog/posts/002/">üá∫üá∏</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><p>Suponha que precisamos calcular dados a partir de um indicador cumulativo para gerar gr√°ficos ou m√©tricas em tempo real para interpreta√ß√£o por parte dos usu√°rios de uma aplica√ß√£o. No entanto, esse indicador √© gerenciado por um processo externo, e n√£o temos como saber exatamente quando ele √© atualizado. Quais estrat√©gias podemos adotar para processar essas informa√ß√µes?</p>
<p>Esse √© um problema que encontrei em um projeto e que, a primeira vista, parece simples. No entanto, sua solu√ß√£o envolve algumas ideias interessantes, al√©m de estar presente em v√°rias funcionalidades de softwares com os quais interagimos no nosso dia a dia.</p>
<p>Um exemplo de aplica√ß√£o que lida diretamente com esse tipo de problema, e com a qual frequentemente interagimos, s√£o os monitores de recursos do sistema, como o Monitor do Sistema (no Linux), Gerenciador de Tarefas (no Windows), ou ferramentas de monitoramentos de recursos de servidores. Essas aplica√ß√µes lidam com esse problema para calcular os gr√°ficos que mostram o volume de tr√°fego de rede dentro das interfaces de rede da m√°quina.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/20250216150855.png"></p>
<p>Esses gr√°ficos s√£o geralmente constru√≠dos da seguinte forma:</p>
<p>O Sistema Operacional √© respons√°vel por coordenar a comunica√ß√£o com o hardware. Ele processa os dados recebidos para montar os pacotes, envia-os para as aplica√ß√µes, e tamb√©m recebe pacotes das aplica√ß√µes para serem processados e enviados ao hardware. Durante esse processo, o sistema, como intermedi√°rio de toda a comunica√ß√£o, tem a capacidade de registrar estat√≠sticas dos dados recebidos e enviados pelas interfaces de rede. Ele ent√£o acumula indicadores para refletir os dados que processou. No entanto, ele n√£o mant√©m um hist√≥rico desses valores, uma vez que isso demandaria o uso crescente da mem√≥ria RAM, o que eventualmente poderia sobrecarregar o sistema. Portanto ele salva apenas um indicador monot√¥nico.</p>
<p>No Linux, por exemplo, o sistema contabiliza os indicadores de entrada e sa√≠da como: bytes, pacotes, erros, drops, FIFO, frames, compress√£o e multicast no arquivo virtual <code>/proc/net/dev</code>.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/20250216152007.png"></p>
<p>Como no caso de exemplo a inten√ß√£o √© somente de calcular o volume de bytes recebidos ou enviados pelo adaptador uma aplica√ß√£o de monitoramento pode usar o indicador <code>bytes</code>, ele √© sempre incremental, e tem duas vers√µes que contabilizam o total de bytes recebidos e enviados pela interface desde sua inicializa√ß√£o.</p>
<p>Observando nosso indicador, vemos nossas premissas para esse problema:</p>
<ul>
<li>o indicador √© sempre incremental</li>
<li>n√£o temos registro dos valores anteriores</li>
<li>n√£o temos controle de exatamente quando esse valor √© atualizado</li>
</ul>
<p>Com isso, √© poss√≠vel usar essa aplica√ß√£o do problema para investigar como calcular uma m√©trica com as mesmas condi√ß√µes. Para simplificar o exemplo, vamos focar apenas na taxa de download, mas as mesmas ideias tamb√©m seriam aplic√°veis √† taxa de upload.</p>
<p>Neste artigo, usando o exemplo, explorarei como gerar essas m√©tricas e, de forma mais profunda, como abordar o c√°lculo do primeiro indicador em tempo real.</p>
<h1 id="definindo-o-modelo-dos-dados">Definindo o modelo dos dados<a hidden class="anchor" aria-hidden="true" href="#definindo-o-modelo-dos-dados">#</a></h1>
<p>Em primeiro lugar, o c√°lculo do indicador √© razoavelmente simples, pois j√° existe um modelo de dados bem estabelecido para interpretar esse problema: as s√©ries temporais (<em>time series</em>). Podemos definir um intervalo ‚àÜt, que pode ser usado para capturar repetidamente os dados do indicador, e a partir desses dados construir a s√©rie temporal. Assim, cada registro da s√©rie seguiria o seguinte formato:</p>
<p>(timestamp, bytes atuais)</p>
<p>Ent√£o, a s√©rie pode ser definida como
</p>
\[
\begin{aligned}
S_{c} = (i=0,...n)\left\{ \left< t_{i},bytes_{i}\right>\right\}
\end{aligned}
\]
<p>
onde:
</p>
\[
\begin{aligned}
t_{x} = t_{0} + \Delta t \times x
\end{aligned}
\]
<p>e i √© um numero indicando o elemento atual (come√ßando por zero)</p>
<p>Claro, para crit√©rios de efici√™ncia, n√£o seria vi√°vel manter toda a s√©rie em mem√≥ria, pois ela cresce continuamente, o que eventualmente geraria um impacto significativo no uso de mem√≥ria do sistema. O uso de s√©ries simplifica a modelagem, e com ela definida podemos s√≥ manter em mem√≥ria os registros que ser√£o necess√°rios para os c√°lculos naquele momento.</p>
<p>A partir dessa s√©rie, podemos calcular a varia√ß√£o da velocidade de download em cada instante, gerando uma nova s√©rie:</p>
\[
\begin{aligned}
S_{d} = (i=0,...n)\left\{ \left< t_{i},bytes_{i} - bytes_{i-1}\right>\right\}
\end{aligned}
\]
<p>E a partir disso √© poss√≠vel personalizar a forma de atualizar o indicador de forma que ele fique mais amig√°vel para o usu√°rio, usando t√©cnicas bem estabelecidas de processamento de s√©ries temporais. Um bom exemplo para nosso caso de rede seria a de janelas m√≥veis.</p>
<p>Mas nosso indicador tem um problema, que √© importante em algumas situa√ß√µes.</p>
<h2 id="problemas-do-modelo">Problemas do modelo<a hidden class="anchor" aria-hidden="true" href="#problemas-do-modelo">#</a></h2>
<p>Veja que na nossa time series derivada dependemos da presen√ßa de \( t_{i-1} \) para calcular \( t_{i} \), mas isso dependeria da exist√™ncia de um \( t_{-1} \) para calcular \( t_{0} \), o que n√£o √© poss√≠vel. Para grande parte das aplica√ß√µes isso n√£o √© relevante, porque poder√≠amos computar o indicador a partir de i = 1, No entanto, isso impede que o indicador seja exibido imediatamente para o usu√°rio, fazendo com que ele precise esperar ‚àÜt para ver o primeiro valor, o que pode n√£o ser muito legal para a aplica√ß√£o, como √© o caso do monitor de recursos, onde o usu√°rio espera que o programa abra instantaneamente.</p>
<p>Essa √© a parte mais interessante desse problema sobre a qual eu n√£o tinha encontrado nada mencionando antes, as t√©cnicas para computar esse indicador de forma imediata.</p>
<p>Apesar de nenhuma delas ser perfeita, elas exigem um olhar criativo para a solu√ß√£o do problema, o que leva a algumas ideias interessantes.</p>
<h1 id="calculando-o-primeiro-item">Calculando o primeiro item<a hidden class="anchor" aria-hidden="true" href="#calculando-o-primeiro-item">#</a></h1>
<p>A primeira t√©cnica, que √© a mais simples, mas que gera desvios significativos por n√£o representar o estado atual, √© simplesmente definir \( S_{d_{0}} = (t_{0}, 0) \), usando 0 como placeholder para primeira posi√ß√£o.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/1st-approach.gif"></p>
<p>Apesar da vantagem de ela ser mais simples, se o usu√°rio que est√° usando a aplica√ß√£o n√£o souber desse comportamento, ele pode ter uma ideia errada de que o indicador aumentou repentinamente pouco depois de ele abrir seu monitoramento</p>
<p>As pr√≥ximas t√©cnicas tamb√©m dependem de certa forma de manipular os dados de forma n√£o completamente precisa, mas de uma forma que informa melhor sobre o contexto atual.</p>
<p>Mas para usar elas, primeiramente precisar√≠amos pensar no nosso modelo de dados de forma um pouco diferente.</p>
<h2 id="novo-modelo-de-dados">Novo modelo de dados<a hidden class="anchor" aria-hidden="true" href="#novo-modelo-de-dados">#</a></h2>
<p>Para as pr√≥ximas t√©cnicas, precisamos flexibilizar a depend√™ncia de que nossa coleta de dados sempre ter√° um intervalo ‚àÜt.</p>
<p>Para simplificar a defini√ß√£o da solu√ß√£o, vamos primeiramente definir a fun√ß√£o \(vS_{d}(x)\) que retorna o valor da s√©rie Sc quando i = x.</p>
<p>O que precisamos para as pr√≥ximas abordagens √© uma formula onde mesmo que o intervalo de tempo entre \(S_{c_{i}}\) e \(S_{c_{i-1}}\) usados seja diferente de Œît, ele seja compar√°vel proporcionalmente aos demais itens da s√©rie. Uma forma de fazer isso √© definindo Sd como:</p>
\[
\begin{aligned}
S_{d} = (i=0,...n)\left\{ \left< t_{i},  (\frac{ \Delta t }{ t_{i} - t_{i-1} }) \times ( vS_{c}(i) - vS_{c}(i-1)  )   \right>\right\}
\end{aligned}
\]
<p>Ou seja, para cada um dos itens da s√©rie \(S_{d}\), consideramos os 2 √∫ltimos itens da s√©rie \(S_{c}\), mas transformados proporcionalmente √† rela√ß√£o entre o intervalo de tempo de coleta do indicador e o tempo padr√£o da s√©rie (‚àÜt).</p>
<p>Com essa defini√ß√£o de s√©rie \(S_{d}\), podemos prosseguir para as pr√≥ximas solu√ß√µes.</p>
<h2 id="segunda-solu√ß√£o">Segunda solu√ß√£o<a hidden class="anchor" aria-hidden="true" href="#segunda-solu√ß√£o">#</a></h2>
<p>A segunda abordagem surge ao percebermos que existe um √∫nico instante de tempo que sabemos que existe anterior a \( t_{0} \), que √© o momento em que o indicador come√ßou a ser incrementado (e o seu valor, que √© zero) dado que ele √© monot√¥nico.</p>
<p>Considerando isso, podemos definir um \( S_{c_{-1}} \) imagin√°rio com esse valor, e come√ßar a calcular nosso \( S_{d} \) a partir de i=0. Assim, o primeiro item de nossa s√©rie consistiria na m√©dia de varia√ß√£o desde o in√≠cio do indicador.</p>
<p>Usando o exemplo do c√°lculo da taxa de download, para essa abordagem, trocamos o <code>timestamp</code> pela vari√°vel de tempo <code>uptime</code> do sistema. O <code>uptime</code> conta quantos nanossegundos se passaram desde que o sistema foi ligado enquanto o <code>timestamp</code> conta a partir de 1 de janeiro de 1970. O <code>uptime</code> √© √∫til para n√≥s nessa abordagem porque ele √© uma boa aproxima√ß√£o de quando nossa interface de rede iniciou seu funcionamento (e por consequ√™ncia o indicador de bytes come√ßou a ser incrementado). Seguindo essa estrat√©gia poder√≠amos definir um \(S_{c_{-1}} = 0\) imagin√°rio, e com isso nosso \(S_{d_{0}}\) seria efetivamente:</p>
\[
\begin{aligned}
S_{d_{0}} = \frac{ \Delta t }{ t_{uptime} } \times vS_{c}(0)
\end{aligned}
\]
<p>Que seria a m√©dia de uso desde que o computador foi ligado.</p>
<p>Segue um exemplo de como um gr√°fico com sua computa√ß√£o pareceria em tempo real.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/2nd-approach.gif"></p>
<p>O problema desse caso √© o fato de que a maior parte do contexto coletado para gerar o primeiro indicador √© antigo, e pouco corresponde a realidade naquele momento. Por exemplo no gr√°fico acima, usando o monitoramento de rede, o usu√°rio passou um grande per√≠odo de tempo fazendo um download grande, mas agora est√° tendo uma carga de rede bem menor. nesse caso a velocidade de download inicial tem um desvio significativo para cima.</p>
<p>Ainda assim essa abordagem √© frequentemente usada, por exemplo, no System Monitor (equivalente ao gerenciador de tarefas do KDE Plasma) √© assim que o grafico de uso de CPU calcula sua primeira posi√ß√£o.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/20250224044328.png"></p>
<h2 id="terceira-solu√ß√£o">Terceira solu√ß√£o<a hidden class="anchor" aria-hidden="true" href="#terceira-solu√ß√£o">#</a></h2>
<p>Finalmente, a terceira abordagem (e minha favorita) para resolver o problema do primeiro ponto de dados parte da percep√ß√£o humana do que consideramos como &ldquo;instant√¢neo&rdquo;.</p>
<p>N√≥s humanos n√£o conseguimos ver grande diferen√ßa entre per√≠odos de tempo curtos, por exemplo entre algo que carrega em 100ms e algo que carrega em 300ms, mas notamos bastante essa diferen√ßa entre algo que carrega em 300ms e 900ms. Dessa forma, se tivermos um pequeno delay de at√© 300 milissegundos para a primeira abertura do nosso indicador, para um humano, este teria efetivamente um carregamento instant√¢neo em sua percep√ß√£o.</p>
<p>Podemos usar esse tempo para calcular um indicador relativo desse per√≠odo de tempo menor. Para isso capturar√≠amos em um per√≠odo de tempo menor que Œît, e (que √© na pr√°tica impercept√≠vel para o usu√°rio (podemos defini-lo como Œîdelay) a amostra \(S_{c_{0}}\) cujo tempo seria \(t_{0} + \Delta delay\), e considerar√≠amos nossa base imagin√°ria \(S_{c_{-1}}\) com a nossa amostra em \(t_{0}\)</p>
<p>Fazendo isso, na nossa s√©rie derivada, teriamos efetivamente na primeira posi√ß√£o:</p>
\[
\begin{aligned}
S_{d_{0}} = \frac{\Delta t}{\Delta delay} \times vS_{c}( t_{0} + \Delta delay ) - vS_{c}(t_{0})
\end{aligned}
\]
<p>Usando isso, seria poss√≠vel calcular \(S_{d_{0}}\) utilizando apenas o tempo Œî<em>delay</em> ao inv√©s de precisar esperar Œî<em>t</em>.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/002/3rd-approach.gif"></p>
<p>Essa abordagem tem a vantagem de que seus dados refletem uma velocidade mais atual, mas ela tamb√©m tem um problema. Como n√£o controlamos a taxa de atualiza√ß√£o do processo interno que incrementa o indicador, nosso Œî<em>delay</em> tem que ser maior do que o pior caso de atualiza√ß√£o desse valor, caso contr√°rio o nosso primeiro resultado ter√° o comportamento da primeira abordagem.</p>
<p>Al√©m disso, se o sistema de atualiza√ß√£o dos dados tiver um intervalo entre 0,5 e 0,999&hellip; vezes o ‚àÜdelay, o resultado pode apresentar um desvio de at√© 50% do valor correto.</p>
<p>Ainda assim, essa solu√ß√£o √© √∫til na maioria dos casos em que precisamos calcular o primeiro indicador em tempo real, embora n√£o exista uma solu√ß√£o perfeita para esse tipo de problema.</p>
<p>Por fim, como na maioria das situa√ß√µes de desenvolvimento, vemos mais um caso onde n√£o existe uma solu√ß√£o perfeita, mas solu√ß√µes com trade-offs que temos que avaliar e escolher de acordo com a natureza do problema que estamso resolvendo.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/blog/pt/">Luiz G. Fran√ßa</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
