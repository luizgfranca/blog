<!DOCTYPE html>
<html lang="pt" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor. | Luiz G. França</title>
<meta name="keywords" content="">
<meta name="description" content="Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).
try {
	const response1 = await fetch(&#39;http://localhost:3000/events&#39;);
	const data1 = await response1.json();
	console.log(&#39;First request response:&#39;, data1);
	
	const response2 = await fetch(&#39;http://localhost:3000/events&#39;);
	const data2 = await response2.json();
	console.log(&#39;Second request response:&#39;, data2);
	
} catch (error) {
	console.error(&#39;Error making requests:&#39;, error);
}
Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!
Isso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.">
<meta name="author" content="">
<link rel="canonical" href="https://luizgfranca.github.io/blog/pt/posts/003/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://luizgfranca.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://luizgfranca.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://luizgfranca.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://luizgfranca.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://luizgfranca.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://luizgfranca.github.io/blog/posts/003/">
<link rel="alternate" hreflang="pt" href="https://luizgfranca.github.io/blog/pt/posts/003/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://luizgfranca.github.io/blog/pt/posts/003/">
  <meta property="og:site_name" content="Luiz G. França">
  <meta property="og:title" content="Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.">
  <meta property="og:description" content="Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).
try { const response1 = await fetch(&#39;http://localhost:3000/events&#39;); const data1 = await response1.json(); console.log(&#39;First request response:&#39;, data1); const response2 = await fetch(&#39;http://localhost:3000/events&#39;); const data2 = await response2.json(); console.log(&#39;Second request response:&#39;, data2); } catch (error) { console.error(&#39;Error making requests:&#39;, error); } Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!
Isso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.">
  <meta property="og:locale" content="pt">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-19T16:59:50-03:00">
    <meta property="article:modified_time" content="2025-06-19T16:59:50-03:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.">
<meta name="twitter:description" content="Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).
try {
	const response1 = await fetch(&#39;http://localhost:3000/events&#39;);
	const data1 = await response1.json();
	console.log(&#39;First request response:&#39;, data1);
	
	const response2 = await fetch(&#39;http://localhost:3000/events&#39;);
	const data2 = await response2.json();
	console.log(&#39;Second request response:&#39;, data2);
	
} catch (error) {
	console.error(&#39;Error making requests:&#39;, error);
}
Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!
Isso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://luizgfranca.github.io/blog/pt/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.",
      "item": "https://luizgfranca.github.io/blog/pt/posts/003/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.",
  "name": "Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.",
  "description": "Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).\ntry { const response1 = await fetch(\u0026#39;http://localhost:3000/events\u0026#39;); const data1 = await response1.json(); console.log(\u0026#39;First request response:\u0026#39;, data1); const response2 = await fetch(\u0026#39;http://localhost:3000/events\u0026#39;); const data2 = await response2.json(); console.log(\u0026#39;Second request response:\u0026#39;, data2); } catch (error) { console.error(\u0026#39;Error making requests:\u0026#39;, error); } Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!\nIsso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.\n",
  "keywords": [
    
  ],
  "articleBody": "Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).\ntry { const response1 = await fetch('http://localhost:3000/events'); const data1 = await response1.json(); console.log('First request response:', data1); const response2 = await fetch('http://localhost:3000/events'); const data2 = await response2.json(); console.log('Second request response:', data2); } catch (error) { console.error('Error making requests:', error); } Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!\nIsso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.\nComo isso acontece? O backend (ou qualquer servidor de aplicação que possa estar executando ele, ou pelo qual suas respostas podem estar passando) pode adicionar o header Cache-Control com algum valor que instrui o navegador a usar o cache interno, por exemplo. Cache-Control: max-age=10 faz com que qualquer chamada subsequente nos próximos 10 segundos use o cache ao invés de chamar o backend novamente.\nIsso é um comportamento esperado da maior parte dos recursos, mas o que pode surpreender é o fato de que isso não funciona somente para páginas HTML, imagens ou arquivos JS, mas para chamadas feitas com fetch também.\nPor exemplo, se no backend um controller for implementado para responder a /event/latest gerando um UUID único para cada chamada:\napp.get('/event/latest', (req, res) =\u003e { const key = uuid.v4(); res.json({ key }) }) E executarmos o código acima no navegador, teremos o comportamento esperado.\n(veja que obtivemos 2 IDs diferentes).\nMas se fizermos um pequeno ajuste no backend.\napp.get('/event/latest', (req, res) =\u003e { const key = uuid.v4(); res.header('Cache-Control', 'max-age=60') res.json({ key }) }) Teremos o seguinte resultado: E se recarregarmos a página antes dos pŕoximos 60 segundos: olhando para a aba de network veremos 4 requests: mas olhando para os 3 últimos… (note o “from disk cache”).\nEsse não é um comportamento exclusivo dessa composição de header. O comportamento de quaisquer regras de headers de cache (que podem ser encontrados em https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control) vai funcionar para o fetch, mais conceitos sobre cache também podem ser encontrados em https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Caching.\nPor que isso acontece? Com a modernização das tecnologias web nos anos 2010, uma das iniciativas da W3C foi a formalização do comportamento de busca de recursos em rede, que era algo que nem sempre era tratado da mesma forma em navegadores. Um dos resultados dessa formalização foi a criação da ideia generalizada de fetch de resources, descrita na spec fetch (https://fetch.spec.whatwg.org/).\nUma das definições dela seria prover uma função para aplicações web que expõe esse conceito de baixo nível. E essa foi a origem da API fetch() que podemos chamar a partir do Javascript, e que foi introduzida em 2015 no ECMAScript 6 (ES6).\nPor conta dessa origem, ela representa o mesmo conceito de busca de recursos de um serviço web que é usado por outras funcionalidades do navegador que fazem a mesma coisa, como a busca dos documentos HTML, imagens, JS, etc… E por isso compartilha o mesmo caminho no código, o que inclui o cache HTTP, que faz com que esse comportamento aconteça.\nPara reproduzir os experimentos demonstrados aqui, o código usado está disponível nesse repositório do Github: https://github.com/luizgfranca/fetch-cache-example\n",
  "wordCount" : "530",
  "inLanguage": "pt",
  "datePublished": "2025-06-19T16:59:50-03:00",
  "dateModified": "2025-06-19T16:59:50-03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://luizgfranca.github.io/blog/pt/posts/003/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Luiz G. França",
    "logo": {
      "@type": "ImageObject",
      "url": "https://luizgfranca.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://luizgfranca.github.io/blog/pt/" accesskey="h" title="Luiz G. França (Alt + H)">Luiz G. França</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://luizgfranca.github.io/blog/" title="🇺🇸"
                            aria-label=":us:">🇺🇸</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://luizgfranca.github.io/blog/pt/">Início</a>&nbsp;»&nbsp;<a href="https://luizgfranca.github.io/blog/pt/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Por que mesmo um request fetch que respondeu talvez não realmente tenha ido no seu servidor.
    </h1>
    <div class="post-meta"><span title='2025-06-19 16:59:50 -0300 -03'>junho 19, 2025</span>&nbsp;|&nbsp;Traduções:
<ul class="i18n_list">
    <li>
        <a href="https://luizgfranca.github.io/blog/posts/003/">🇺🇸</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><p>Quando você vê esse trecho de código, quantas chamadas de rede você acredita que serão feitas quando ele for executado no navegador? (suponha que qualquer requisição feita será bem sucedida).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">response1</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://localhost:3000/events&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">data1</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">response1</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;First request response:&#39;</span><span class="p">,</span> <span class="nx">data1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">response2</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://localhost:3000/events&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kr">const</span> <span class="nx">data2</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">response2</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Second request response:&#39;</span><span class="p">,</span> <span class="nx">data2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">&#39;Error making requests:&#39;</span><span class="p">,</span> <span class="nx">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Surpreendentemente, podem ser duas, uma, ou até mesmo nenhuma!</p>
<p>Isso porque o navegador vai decidir mandar ou não as requisições dependendo das respostas anteriores que ele recebeu do seu backend.</p>
<h2 id="como-isso-acontece">Como isso acontece?<a hidden class="anchor" aria-hidden="true" href="#como-isso-acontece">#</a></h2>
<p>O backend (ou qualquer servidor de aplicação que possa estar executando ele, ou pelo qual suas respostas podem estar passando) pode adicionar o header <code>Cache-Control</code> com algum valor que instrui o navegador a usar o cache interno, por exemplo. <code>Cache-Control: max-age=10</code> faz com que qualquer chamada subsequente nos próximos 10 segundos use o cache ao invés de chamar o backend novamente.</p>
<p>Isso é um comportamento esperado da maior parte dos recursos, mas o que pode surpreender é o fato de que isso não funciona somente para páginas HTML, imagens ou arquivos JS, mas para chamadas feitas com <code>fetch</code> também.</p>
<p>Por exemplo, se no backend um controller for implementado para responder a <code>/event/latest</code> gerando um UUID único para cada chamada:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/event/latest&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">v4</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">key</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>E executarmos o código acima no navegador, teremos o comportamento esperado.</p>
<p><img alt="image" loading="lazy" src="/blog/posts/003/img20250618210010.png">
(veja que obtivemos 2 IDs diferentes).</p>
<p>Mas se fizermos um pequeno ajuste no backend.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/event/latest&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nx">v4</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">.</span><span class="nx">header</span><span class="p">(</span><span class="s1">&#39;Cache-Control&#39;</span><span class="p">,</span> <span class="s1">&#39;max-age=60&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="nx">key</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>Teremos o seguinte resultado:
<img alt="image" loading="lazy" src="/blog/posts/003/img20250618210451.png"></p>
<p>E se recarregarmos a página antes dos pŕoximos 60 segundos:
<img alt="image" loading="lazy" src="/blog/posts/003/img20250618210519.png"></p>
<p>olhando para a aba de network veremos 4 requests:
<img alt="image" loading="lazy" src="/blog/posts/003/img20250618210735.png"></p>
<p>mas olhando para os 3 últimos&hellip;
<img alt="image" loading="lazy" src="/blog/posts/003/img20250618210836.png">
(note o &ldquo;from disk cache&rdquo;).</p>
<p>Esse não é um comportamento exclusivo dessa composição de header. O comportamento de quaisquer regras de headers de cache (que podem ser encontrados em <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control</a>) vai funcionar para o <code>fetch</code>, mais conceitos sobre cache também podem ser encontrados em <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Caching">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Caching</a>.</p>
<h2 id="por-que-isso-acontece">Por que isso acontece?<a hidden class="anchor" aria-hidden="true" href="#por-que-isso-acontece">#</a></h2>
<p>Com a modernização das tecnologias web nos anos 2010, uma das iniciativas da W3C foi a formalização do comportamento de busca de recursos em rede, que era algo que nem sempre era tratado da mesma forma em navegadores. Um dos resultados dessa formalização foi a criação da ideia generalizada de <code>fetch</code> de <code>resources</code>, descrita na spec <code>fetch</code> (<a href="https://fetch.spec.whatwg.org/%29">https://fetch.spec.whatwg.org/)</a>.</p>
<p>Uma das definições dela seria prover uma função para aplicações web que expõe esse conceito de baixo nível. E essa foi a origem da API <code>fetch()</code> que podemos chamar a partir do Javascript, e que foi introduzida em 2015 no ECMAScript 6 (ES6).</p>
<p>Por conta dessa origem, ela representa o mesmo conceito de busca de recursos de um serviço web que é usado por outras funcionalidades do navegador que fazem a mesma coisa, como a busca dos documentos HTML, imagens, JS, etc&hellip; E por isso compartilha o mesmo caminho no código, o que inclui o cache HTTP, que faz com que esse comportamento aconteça.</p>
<hr>
<p>Para reproduzir os experimentos demonstrados aqui, o código usado está disponível nesse repositório do Github: <a href="https://github.com/luizgfranca/fetch-cache-example">https://github.com/luizgfranca/fetch-cache-example</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://luizgfranca.github.io/blog/pt/posts/002/">
    <span class="title">Próxima Página »</span>
    <br>
    <span>Como calcular uma primeira medição instantânea de métricas sobre indicadores cumulativos em tempo real</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://luizgfranca.github.io/blog/pt/">Luiz G. França</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
